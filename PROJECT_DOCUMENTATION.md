# Подробная документация проекта MoscowTime iOS

## Оглавление

1. [Общее описание проекта](#общее-описание-проекта)
2. [Архитектура приложения](#архитектура-приложения)
3. [Детальное описание файлов](#детальное-описание-файлов)
4. [Функциональность будильников](#функциональность-будильников)
5. [Процесс сборки и деплоя](#процесс-сборки-и-деплоя)
6. [Установка на iPhone](#установка-на-iphone)
7. [Технические детали](#технические-детали)
8. [Особенности реализации](#особенности-реализации)

---

## Общее описание проекта

### Назначение приложения

**MoscowTime** - это нативное iOS приложение для iPhone, которое:
- Отображает текущее время в Москве (часовой пояс Europe/Moscow)
- Показывает день недели на русском языке
- Показывает полную дату в формате "день месяц год"
- Позволяет создавать будильники (повторяющиеся и разовые) с локальными уведомлениями

### Основной функционал

1. **Отображение московского времени**
   - Время обновляется каждую секунду
   - Формат: HH:mm:ss (24-часовой)
   - День недели на русском языке
   - Полная дата в формате "d MMMM yyyy"

2. **Будильники**
   - Повторяющиеся будильники (по умолчанию рабочие дни: понедельник-пятница)
   - Разовые будильники (одноразовое срабатывание)
   - Локальные уведомления через UNUserNotificationCenter
   - Все будильники работают в московском времени

### Технологии

- **Язык**: Swift 5.0
- **UI Framework**: SwiftUI
- **Минимальная версия iOS**: 15.0
- **Часовой пояс**: Europe/Moscow (UTC+3)
- **Хранение данных**: UserDefaults (JSON encoding)
- **Уведомления**: UserNotifications framework (UNUserNotificationCenter)

### Платформа разработки

- **ОС разработчика**: Windows 10/11
- **IDE**: Cursor (VS Code-based)
- **Сборка**: GitHub Actions на macOS runner
- **Версия Xcode**: 16.4 (на GitHub Actions runner)

### Репозиторий

- **GitHub**: https://github.com/Progress-collab/moscow-time-ios
- **Основная ветка**: `main`
- **GitHub Actions**: Автоматическая сборка при каждом push

---

## Архитектура приложения

### Общая архитектура

Приложение использует упрощенную MVVM-подобную архитектуру:

- **Model**: `Alarm` (структура данных)
- **View Model**: `AlarmStore` (управление состоянием и хранением)
- **Manager**: `AlarmManager` (бизнес-логика уведомлений)
- **View**: SwiftUI views (ContentView, AlarmListView, AlarmEditView)

### Потоки данных

```
MoscowTimeApp (App)
    ├── AlarmStore (@StateObject) - создается один раз при запуске
    │   └── alarms: [Alarm] (@Published)
    │
    ├── ContentView
    │   └── @EnvironmentObject alarmStore
    │       └── NavigationLink → AlarmListView
    │
    ├── AlarmListView
    │   └── @ObservedObject alarmStore
    │       └── List → AlarmRowView (для каждого будильника)
    │       └── NavigationLink → AlarmEditView
    │
    └── AlarmManager (singleton)
        └── UNUserNotificationCenter
            └── Локальные уведомления
```

### Управление состоянием

1. **AlarmStore** - централизованное хранилище будильников
   - Использует `@Published` для автоматического обновления UI
   - Передается через `@EnvironmentObject` в SwiftUI
   - Автоматически сохраняет изменения в UserDefaults

2. **AlarmManager** - singleton для управления уведомлениями
   - Не является ObservableObject (не нужно для UI)
   - Используется напрямую через `AlarmManager.shared`
   - Управляет жизненным циклом уведомлений

### Структура проекта

```
MoscowTime/
├── MoscowTimeApp.swift          # Точка входа приложения
├── ContentView.swift            # Главный экран с временем
├── Alarm.swift                  # Модель будильника
├── AlarmStore.swift             # Хранилище будильников
├── AlarmManager.swift           # Менеджер уведомлений
├── AlarmListView.swift          # Список будильников
├── AlarmEditView.swift          # Редактирование будильника
├── Info.plist                   # Метаданные приложения
└── Assets.xcassets/             # Ресурсы (иконки)
    └── AppIcon.appiconset/

MoscowTime.xcodeproj/            # Файл проекта Xcode
├── project.pbxproj              # Конфигурация проекта

.github/workflows/
└── build.yml                    # GitHub Actions workflow

ExportOptions.plist              # Настройки экспорта IPA
update-app.ps1                   # Скрипт для быстрого обновления
TESTING.md                       # Инструкции по тестированию
README.md                        # Основная документация
```

---

## Детальное описание файлов

### MoscowTimeApp.swift

**Назначение**: Точка входа приложения, инициализация и настройка.

**Ключевые компоненты**:
- `@main` - точка входа SwiftUI приложения
- `@StateObject private var alarmStore` - создание единственного экземпляра AlarmStore
- `init()` - запрос разрешения на уведомления при запуске
- `.environmentObject(alarmStore)` - передача AlarmStore в иерархию views
- `.onAppear` - обновление всех будильников при запуске

**Важные детали**:
- Запрос разрешения на уведомления происходит в `init()`, до создания UI
- После получения разрешения автоматически обновляются все будильники
- AlarmStore создается один раз и живет весь жизненный цикл приложения

### ContentView.swift

**Назначение**: Главный экран приложения, отображение московского времени.

**Ключевые компоненты**:
- `@EnvironmentObject var alarmStore` - получение AlarmStore из окружения
- `@State private var currentTime` - текущее время для обновления UI
- `Timer.publish(every: 1)` - таймер обновления каждую секунду
- `moscowTimeZone` - часовой пояс Europe/Moscow

**Функции форматирования**:
- `dayOfWeek` - день недели на русском (EEEE format)
- `timeString` - время в формате HH:mm:ss
- `dateString` - дата в формате "d MMMM yyyy"

**UI компоненты**:
- NavigationView с NavigationLink к AlarmListView
- Кнопка "Будильники" внизу экрана
- Отображение времени, дня недели и даты

**Важные детали**:
- Все форматирование использует московский часовой пояс
- Locale установлен на "ru_RU" для русских названий
- Таймер обновляется каждую секунду автоматически

### Alarm.swift

**Назначение**: Модель данных будильника.

**Структура данных**:
```swift
struct Alarm: Identifiable, Codable {
    let id: UUID                    // Уникальный идентификатор
    var hour: Int                   // Час (0-23)
    var minute: Int                 // Минута (0-59)
    var weekdays: Set<Int>          // Дни недели (1=Вс, 2=Пн, ..., 7=Сб)
    var isEnabled: Bool             // Включен/выключен
    var name: String?               // Название (опционально)
    var isOneTime: Bool             // Разовый будильник
    var oneTimeDate: Date?          // Дата для разового будильника
}
```

**Протоколы**:
- `Identifiable` - для использования в SwiftUI List
- `Codable` - для сериализации в JSON (UserDefaults)

**Вычисляемые свойства**:
- `timeString` - форматированное время "HH:mm"
- `weekdaysString` - строковое представление дней недели

**Методы**:
- `nextTriggerDate(in:)` - вычисление следующей даты срабатывания (для повторяющихся)

**Важные детали**:
- По умолчанию `weekdays = [2, 3, 4, 5, 6]` (рабочие дни)
- По умолчанию `isOneTime = false` (повторяющийся)
- `weekdaysString` автоматически определяет "Рабочие дни", "Каждый день" или список дней

### AlarmStore.swift

**Назначение**: Управление хранением и состоянием будильников.

**Класс**: `ObservableObject` для автоматического обновления UI

**Свойства**:
- `@Published var alarms: [Alarm]` - массив будильников
- `private let userDefaultsKey = "MoscowTimeAlarms"` - ключ для UserDefaults

**Методы**:
- `loadAlarms()` - загрузка из UserDefaults при инициализации
- `saveAlarms()` - сохранение в UserDefaults + обновление уведомлений
- `addAlarm(_:)` - добавление нового будильника
- `updateAlarm(_:)` - обновление существующего будильника
- `deleteAlarm(_:)` - удаление будильника
- `toggleAlarm(_:)` - переключение включен/выключен

**Важные детали**:
- При каждом сохранении автоматически вызывается `AlarmManager.shared.updateAllAlarms()`
- Данные хранятся в формате JSON в UserDefaults
- При загрузке приложения автоматически загружаются сохраненные будильники

**Формат хранения**:
- UserDefaults ключ: `"MoscowTimeAlarms"`
- Формат: JSON (Data) → [Alarm] через JSONEncoder/JSONDecoder
- Автоматическая сериализация благодаря протоколу Codable

### AlarmManager.swift

**Назначение**: Управление локальными уведомлениями через UNUserNotificationCenter.

**Класс**: Singleton (`static let shared`)

**Свойства**:
- `private let moscowTimeZone = TimeZone(identifier: "Europe/Moscow")!`
- `private init()` - приватный инициализатор для singleton

**Методы**:

1. **`requestAuthorization(completion:)`**
   - Запрос разрешения на уведомления
   - Опции: `.alert`, `.sound`, `.badge`
   - Выполняется асинхронно с возвратом на main thread

2. **`scheduleAlarm(_:)`**
   - Создание уведомлений для будильника
   - Для разовых: одно уведомление с `repeats: false`
   - Для повторяющихся: отдельное уведомление для каждого дня недели с `repeats: true`
   - Использует `UNCalendarNotificationTrigger` с московским временем

3. **`removeAlarm(_:)`**
   - Удаление всех уведомлений для будильника
   - Для разовых: идентификатор `"{id}-onetime"`
   - Для повторяющихся: идентификаторы `"{id}-{weekday}"` для каждого дня

4. **`updateAllAlarms(_:)`**
   - Удаляет все старые уведомления
   - Создает новые для всех включенных будильников
   - Вызывается при запуске приложения и при сохранении

5. **`checkAuthorizationStatus(completion:)`**
   - Проверка текущего статуса разрешения
   - Возвращает `UNAuthorizationStatus`

**Важные детали**:
- Все уведомления создаются в московском часовом поясе
- Для повторяющихся будильников создается отдельное уведомление для каждого дня недели
- Идентификаторы уведомлений уникальны: `"{alarm.id}-{weekday}"` или `"{alarm.id}-onetime"`
- Разовые будильники проверяются на то, что дата в будущем

### AlarmListView.swift

**Назначение**: Отображение списка всех будильников.

**Компоненты**:
- `AlarmListView` - основной view со списком
- `AlarmRowView` - строка для каждого будильника

**AlarmListView**:
- `@ObservedObject var alarmStore` - получение будильников
- `@State` переменные для управления модальными окнами
- Проверка разрешения на уведомления при появлении
- Отображение пустого состояния, если будильников нет
- Swipe-to-delete для удаления будильников

**AlarmRowView**:
- Отображение времени и дней недели (или даты для разовых)
- Toggle для включения/выключения
- Автоматическое обновление уведомлений при изменении состояния

**Важные детали**:
- Для разовых будильников показывается дата и время вместо дней недели
- При включении/выключении автоматически обновляются уведомления
- При удалении автоматически удаляются связанные уведомления

### AlarmEditView.swift

**Назначение**: Форма создания и редактирования будильника.

**Состояние**:
- `@State` переменные для всех полей формы
- `@State private var isOneTime` - режим разового будильника
- `@State private var oneTimeDate` - дата для разового будильника

**UI компоненты**:
- Toggle "Разовый будильник"
- Условное отображение:
  - Если разовый: DatePicker для даты и времени
  - Если повторяющийся: TimePicker + выбор дней недели
- Кнопки быстрого выбора: "Рабочие дни", "Каждый день"
- Список дней недели с Toggle для каждого дня

**Валидация**:
- Кнопка "Сохранить" отключена, если не выбран ни один день (для повторяющихся)
- Для разовых будильников валидация не требуется

**Метод `saveAlarm()`**:
- Извлекает данные из формы
- Для разовых: берет дату и время из `oneTimeDate`
- Для повторяющихся: использует `selectedHour`, `selectedMinute`, `weekdays`
- Создает объект Alarm и сохраняет через AlarmStore

**Важные детали**:
- DatePicker имеет `.labelsHidden()` для скрытия вертикальной надписи "Время"
- Заголовок секции "Время" остается видимым
- При переключении режима форма автоматически обновляется

### Info.plist

**Назначение**: Метаданные и конфигурация приложения.

**Ключевые параметры**:
- `CFBundleDisplayName`: "Москва" (имя приложения на главном экране)
- `CFBundleIdentifier`: `com.moscowtime.app`
- `NSUserNotificationsUsageDescription`: Описание использования уведомлений
- `IPHONEOS_DEPLOYMENT_TARGET`: 15.0

**Важные детали**:
- `NSUserNotificationsUsageDescription` обязателен для запроса разрешения на уведомления
- Текст отображается пользователю при первом запросе разрешения

---

## Функциональность будильников

### Типы будильников

#### 1. Повторяющиеся будильники

**По умолчанию**: Рабочие дни (понедельник-пятница)

**Как работает**:
- Пользователь выбирает время (часы и минуты)
- Выбирает дни недели (можно выбрать несколько)
- Создается отдельное уведомление для каждого выбранного дня
- Каждое уведомление повторяется еженедельно (`repeats: true`)

**Пример**:
- Будильник на 07:00 в рабочие дни
- Создается 5 уведомлений:
  - Понедельник 07:00 (повторяется каждую неделю)
  - Вторник 07:00 (повторяется каждую неделю)
  - Среда 07:00 (повторяется каждую неделю)
  - Четверг 07:00 (повторяется каждую неделю)
  - Пятница 07:00 (повторяется каждую неделю)

**Идентификаторы уведомлений**:
- Формат: `"{alarm.id}-{weekday}"`
- Пример: `"12345678-1234-5678-1234-567812345678-2"` (для понедельника)

#### 2. Разовые будильники

**Как работает**:
- Пользователь включает переключатель "Разовый будильник"
- Выбирает конкретную дату и время
- Создается одно уведомление на указанную дату и время
- Уведомление не повторяется (`repeats: false`)

**Валидация**:
- Дата должна быть в будущем
- Если дата в прошлом, уведомление не создается

**Идентификатор уведомления**:
- Формат: `"{alarm.id}-onetime"`
- Пример: `"12345678-1234-5678-1234-567812345678-onetime"`

### Работа с московским временем

**Важно**: Все будильники работают в московском времени, независимо от часового пояса устройства.

**Как это реализовано**:
1. При создании уведомления используется `TimeZone(identifier: "Europe/Moscow")`
2. `DateComponents` создаются с указанием `timeZone = moscowTimeZone`
3. `UNCalendarNotificationTrigger` использует эти компоненты с часовым поясом

**Пример**:
- Пользователь в часовом поясе UTC+5 создает будильник на 07:00
- Уведомление сработает в 07:00 по московскому времени
- Если в момент создания в Москве 10:00, а у пользователя 12:00, это не влияет на время срабатывания

### Создание уведомления

**Процесс для повторяющегося будильника**:

1. Пользователь сохраняет будильник
2. `AlarmStore.saveAlarms()` вызывается автоматически
3. `AlarmManager.updateAllAlarms()` вызывается из `saveAlarms()`
4. Для каждого дня недели создается отдельное уведомление:
   ```swift
   var dateComponents = DateComponents()
   dateComponents.weekday = weekday  // 2=Пн, 3=Вт, и т.д.
   dateComponents.hour = alarm.hour
   dateComponents.minute = alarm.minute
   dateComponents.timeZone = moscowTimeZone
   
   let trigger = UNCalendarNotificationTrigger(
       dateMatching: dateComponents, 
       repeats: true
   )
   ```

**Процесс для разового будильника**:

1. Пользователь сохраняет разовый будильник
2. Извлекается дата и время из `oneTimeDate`
3. Создаются компоненты с годом, месяцем, днем, часом, минутой
4. Создается одно уведомление:
   ```swift
   var dateComponents = DateComponents()
   dateComponents.year = components.year
   dateComponents.month = components.month
   dateComponents.day = components.day
   dateComponents.hour = components.hour
   dateComponents.minute = components.minute
   dateComponents.timeZone = moscowTimeZone
   
   let trigger = UNCalendarNotificationTrigger(
       dateMatching: dateComponents, 
       repeats: false
   )
   ```

### Удаление уведомлений

**При удалении будильника**:
- Вызывается `AlarmManager.removeAlarm(_:)`
- Удаляются все уведомления с соответствующими идентификаторами
- Для повторяющихся: удаляются все дни недели
- Для разовых: удаляется одно уведомление

**При обновлении всех будильников**:
- Вызывается `UNUserNotificationCenter.current().removeAllPendingNotificationRequests()`
- Затем создаются новые уведомления для всех включенных будильников
- Это гарантирует синхронизацию между хранилищем и уведомлениями

### Хранение будильников

**Формат**: JSON в UserDefaults

**Ключ**: `"MoscowTimeAlarms"`

**Процесс сохранения**:
1. `AlarmStore.alarms` (массив [Alarm])
2. `JSONEncoder().encode(alarms)` → Data
3. `UserDefaults.standard.set(data, forKey: "MoscowTimeAlarms")`

**Процесс загрузки**:
1. `UserDefaults.standard.data(forKey: "MoscowTimeAlarms")` → Data?
2. `JSONDecoder().decode([Alarm].self, from: data)` → [Alarm]
3. `alarms = decoded`

**Совместимость**:
- Благодаря протоколу Codable, структура Alarm автоматически сериализуется
- Date сериализуется как timestamp
- UUID сериализуется как строка

---

## Процесс сборки и деплоя

### GitHub Actions Workflow

**Файл**: `.github/workflows/build.yml`

**Триггеры**:
- Push в ветки `main` или `master`
- Ручной запуск через `workflow_dispatch`

### Job 1: Lint (Проверка кода)

**Назначение**: Проверка Swift кода на ошибки и предупреждения

**Шаги**:
1. Checkout repository
2. Выбор версии Xcode
3. Показ версии Xcode
4. Сборка для симулятора:
   ```bash
   xcodebuild clean build \
     -project MoscowTime.xcodeproj \
     -scheme MoscowTime \
     -sdk iphonesimulator \
     -configuration Debug \
     -destination 'generic/platform=iOS Simulator' \
     CODE_SIGN_IDENTITY="" \
     CODE_SIGNING_REQUIRED=NO \
     CODE_SIGNING_ALLOWED=NO
   ```
5. Анализ лога на наличие ошибок и предупреждений
6. Загрузка лога как артефакт

**Важные детали**:
- Используется `generic/platform=iOS Simulator` для совместимости с любым доступным симулятором
- `continue-on-error: true` - lint не блокирует сборку, но показывает проблемы
- Лог сохраняется на 7 дней

### Job 2: Build (Сборка и релиз)

**Зависимости**: Выполняется после успешного lint

**Разрешения**: `contents: write` - необходимо для создания Release

**Шаги**:

1. **Checkout и настройка Xcode**
   - Аналогично lint job

2. **Сборка приложения**:
   ```bash
   xcodebuild clean build \
     -project MoscowTime.xcodeproj \
     -scheme MoscowTime \
     -sdk iphoneos \
     -configuration Release \
     -destination 'generic/platform=iOS' \
     CODE_SIGN_IDENTITY="" \
     CODE_SIGNING_REQUIRED=NO \
     CODE_SIGNING_ALLOWED=NO
   ```
   - Сборка для реального устройства (iphoneos)
   - Release конфигурация для оптимизации

3. **Создание архива**:
   ```bash
   xcodebuild archive \
     -project MoscowTime.xcodeproj \
     -scheme MoscowTime \
     -sdk iphoneos \
     -configuration Release \
     -archivePath ./build/MoscowTime.xcarchive \
     CODE_SIGN_IDENTITY="" \
     CODE_SIGNING_REQUIRED=NO \
     CODE_SIGNING_ALLOWED=NO
   ```
   - Создает .xcarchive файл

4. **Экспорт IPA (попытка)**:
   ```bash
   xcodebuild -exportArchive \
     -archivePath ./build/MoscowTime.xcarchive \
     -exportPath ./build/ipa \
     -exportOptionsPlist ExportOptions.plist \
     CODE_SIGN_IDENTITY="" \
     CODE_SIGNING_REQUIRED=NO \
     CODE_SIGNING_ALLOWED=NO || true
   ```
   - Может не сработать без подписи (поэтому `|| true`)

5. **Создание IPA вручную**:
   ```bash
   mkdir -p ./build/ipa/Payload
   cp -r ./build/MoscowTime.xcarchive/Products/Applications/MoscowTime.app ./build/ipa/Payload/
   cd ./build/ipa
   zip -r MoscowTime.ipa Payload
   ```
   - Копирует .app в папку Payload
   - Создает ZIP архив с расширением .ipa

6. **Загрузка IPA как артефакт**:
   - Сохраняется на 30 дней
   - Доступен для скачивания из GitHub Actions

7. **Создание версии и тега**:
   ```bash
   VERSION=$(date +'%Y.%m.%d-%H%M%S')
   echo "version=$VERSION" >> $GITHUB_OUTPUT
   echo "tag=v$VERSION" >> $GITHUB_OUTPUT
   ```
   - Формат версии: `2025.11.16-143022`
   - Формат тега: `v2025.11.16-143022`

8. **Создание GitHub Release**:
   - Использует `softprops/action-gh-release@v1`
   - Создает Release с тегом
   - Прикрепляет IPA файл
   - IPA хранится бессрочно в Release

### ExportOptions.plist

**Назначение**: Конфигурация для экспорта IPA

**Содержимое**:
```xml
<plist>
  <dict>
    <key>method</key>
    <string>development</string>
    <key>signingStyle</key>
    <string>manual</string>
  </dict>
</plist>
```

**Важные детали**:
- Используется для попытки автоматического экспорта
- В большинстве случаев создается IPA вручную (шаг 5)

### Структура project.pbxproj

**Важно**: Этот файл содержит конфигурацию Xcode проекта и должен быть правильно структурирован.

**Основные секции**:
- `PBXBuildFile` - ссылки на файлы для сборки
- `PBXFileReference` - ссылки на файлы в файловой системе
- `PBXGroup` - структура папок в проекте
- `PBXSourcesBuildPhase` - файлы для компиляции
- `PBXResourcesBuildPhase` - ресурсы (Assets.xcassets)
- `XCBuildConfiguration` - настройки сборки (Debug/Release)

**Важные правила**:
- Каждый файл должен иметь уникальный ID
- ID в PBXBuildFile должен ссылаться на ID в PBXFileReference
- Все Swift файлы должны быть в PBXSourcesBuildPhase
- Assets.xcassets должен быть в PBXResourcesBuildPhase

**Известные проблемы**:
- Если один ID используется дважды, проект не откроется
- Ошибка: `-[XCConfigurationList group]: unrecognized selector`
- Решение: Найти конфликтующие ID и заменить на уникальные

---

## Установка на iPhone

### Требования

**На компьютере (Windows)**:
- iTunes (не из Microsoft Store) - обязательно
- AltServer (для AltStore) - опционально, может потребовать iCloud
- Sideloadly - альтернатива AltStore, не требует iCloud

**На iPhone**:
- iOS 15.0 или выше
- Разблокированный iPhone
- Доверие компьютеру

### Процесс установки через AltStore

**Подготовка**:
1. Установите iTunes с официального сайта Apple
2. Установите AltServer с https://altstore.io/
3. Если AltServer просит iCloud - установите его (может быть не всегда обязательно)

**Установка AltStore на iPhone**:
1. Подключите iPhone к компьютеру
2. Запустите AltServer на компьютере
3. Откройте AltStore на iPhone (если уже установлен) или установите через AltServer
4. AltStore должен увидеть iPhone

**Установка приложения**:
1. Скачайте IPA файл с GitHub Releases
2. Откройте AltStore на iPhone
3. Нажмите "+" → выберите IPA файл
4. Введите Apple ID и пароль
5. Доверьте разработчика: Настройки → Основные → VPN и управление устройством

**Переподпись (каждые 7 дней)**:
1. Подключите iPhone к компьютеру
2. Запустите AltServer на компьютере
3. Откройте AltStore на iPhone
4. AltStore автоматически обновит сертификаты

### Процесс установки через Sideloadly

**Подготовка**:
1. Установите iTunes (не из Microsoft Store)
2. Скачайте Sideloadly с https://sideloadly.io/

**Установка**:
1. Подключите iPhone к компьютеру
2. Откройте Sideloadly
3. Выберите IPA файл
4. Введите Apple ID и пароль
5. Выберите устройство
6. Нажмите "Start"
7. Доверьте разработчика на iPhone

**Переподпись (каждые 7 дней)**:
- Повторите процесс установки (шаги 1-7)
- Sideloadly автоматически обновит сертификат

### Troubleshooting

**iPhone не виден в iTunes/AltServer/Sideloadly**:
1. Проверьте USB кабель (используйте оригинальный)
2. Разблокируйте iPhone
3. Подтвердите "Доверять этому компьютеру?"
4. Перезапустите iTunes/AltServer/Sideloadly
5. Перезагрузите iPhone
6. Перезагрузите компьютер
7. Проверьте, что iTunes запущен (для AltServer/Sideloadly)

**AltServer просит установить iCloud**:
- Установите iCloud с официального сайта Apple
- Или используйте Sideloadly (не требует iCloud)

**Ошибка при установке**:
- Проверьте, что IPA файл скачан полностью
- Убедитесь, что iPhone разблокирован
- Проверьте подключение к интернету (для создания сертификата)

---

## Технические детали

### Code Signing

**Текущий подход**: Без подписи (unsigned IPA)

**Почему**:
- Сборка происходит на GitHub Actions без Apple Developer аккаунта
- IPA создается вручную без подписи
- Подпись выполняется при установке через AltStore/Sideloadly

**Как работает подпись при установке**:
1. AltStore/Sideloadly использует ваш Apple ID
2. Создается бесплатный сертификат разработчика
3. IPA подписывается этим сертификатом
4. Сертификат действителен 7 дней (бесплатный Apple ID)

**Альтернативы**:
- Платный Apple Developer аккаунт ($99/год) - сертификат на 1 год
- TestFlight - требует платный аккаунт

### Уведомления (UserNotifications)

**Framework**: UserNotifications (UNUserNotificationCenter)

**Разрешения**:
- `.alert` - показ уведомлений
- `.sound` - звук уведомлений
- `.badge` - бейдж на иконке приложения

**Запрос разрешения**:
- Происходит при первом запуске приложения
- Пользователь может разрешить или запретить
- Если запрещено, будильники не будут работать

**Создание уведомлений**:
- Используется `UNCalendarNotificationTrigger`
- Триггер основан на календарных компонентах (день недели, час, минута)
- Поддерживает повторение (`repeats: true/false`)

**Идентификаторы**:
- Должны быть уникальными
- Формат: `"{alarm.id}-{weekday}"` или `"{alarm.id}-onetime"`
- Используются для удаления и обновления уведомлений

**Ограничения iOS**:
- Максимум 64 уведомления на приложение
- Система автоматически удаляет старые уведомления при превышении лимита
- Уведомления работают даже когда приложение закрыто

### Часовой пояс (Московское время)

**Идентификатор**: `"Europe/Moscow"`

**Особенности**:
- Москва использует UTC+3 (MSK)
- Переход на летнее время отменен с 2014 года
- Часовой пояс фиксированный

**Реализация**:
- Все DateFormatter используют `timeZone = TimeZone(identifier: "Europe/Moscow")`
- Все DateComponents создаются с указанием московского часового пояса
- UNCalendarNotificationTrigger использует компоненты с часовым поясом

**Важно**:
- Время будильников всегда в московском времени
- Не зависит от часового пояса устройства пользователя
- Если пользователь находится в другом часовом поясе, будильник все равно сработает в московское время

### UserDefaults для хранения

**Ключ**: `"MoscowTimeAlarms"`

**Формат**: JSON (Data)

**Преимущества**:
- Простота использования
- Автоматическая синхронизация через iCloud (если включено)
- Не требует дополнительных зависимостей

**Ограничения**:
- Не подходит для больших объемов данных
- Не подходит для сложных запросов
- Для этого проекта достаточно

**Альтернативы** (если понадобится в будущем):
- Core Data - для сложных данных и запросов
- SQLite - для больших объемов данных
- CloudKit - для синхронизации между устройствами

### Структура project.pbxproj

**Формат**: Property List (plist) в текстовом формате

**Основные объекты**:

1. **PBXBuildFile** - файлы для сборки
   ```xml
   A100000D294A1A000000000D /* Alarm.swift in Sources */ = {
     isa = PBXBuildFile;
     fileRef = A1000007294A1A0000000007 /* Alarm.swift */;
   };
   ```

2. **PBXFileReference** - ссылки на файлы
   ```xml
   A1000007294A1A0000000007 /* Alarm.swift */ = {
     isa = PBXFileReference;
     lastKnownFileType = sourcecode.swift;
     path = Alarm.swift;
     sourceTree = "<group>";
   };
   ```

3. **PBXGroup** - структура папок
   ```xml
   A1000003294A1A0000000004 /* MoscowTime */ = {
     isa = PBXGroup;
     children = (
       A1000000294A1A0000000001 /* MoscowTimeApp.swift */,
       A1000007294A1A0000000007 /* Alarm.swift */,
       ...
     );
     path = MoscowTime;
     sourceTree = "<group>";
   };
   ```

4. **PBXSourcesBuildPhase** - файлы для компиляции
   ```xml
   A0FFFFFB294A1A0000000000 /* Sources */ = {
     isa = PBXSourcesBuildPhase;
     files = (
       A100000D294A1A000000000D /* Alarm.swift in Sources */,
       ...
     );
   };
   ```

**Важные правила**:
- Каждый объект должен иметь уникальный ID (24 символа hex)
- ID в PBXBuildFile.fileRef должен соответствовать ID в PBXFileReference
- Все Swift файлы должны быть в PBXSourcesBuildPhase
- Порядок файлов в PBXGroup важен для отображения в Xcode

**Известные проблемы и решения**:

1. **Конфликт ID**:
   - Симптом: `-[XCConfigurationList group]: unrecognized selector`
   - Причина: Один ID используется для разных типов объектов
   - Решение: Найти конфликт и заменить ID на уникальный

2. **Файл не компилируется**:
   - Проверить, что файл есть в PBXFileReference
   - Проверить, что файл есть в PBXBuildFile
   - Проверить, что файл есть в PBXSourcesBuildPhase
   - Проверить, что fileRef в PBXBuildFile соответствует ID файла

---

## Особенности реализации

### Почему выбран такой подход

#### 1. Разработка на Windows без Mac

**Проблема**: iOS разработка традиционно требует Mac и Xcode

**Решение**: GitHub Actions с macOS runner
- Бесплатные GitHub Actions для публичных репозиториев
- Автоматическая сборка при каждом push
- Не требует локального Mac

**Альтернативы, которые были рассмотрены**:
- PWA (Progressive Web App) - отклонено из-за отсутствия push-уведомлений на iOS
- Облачные Mac сервисы - платные и сложные
- Виртуальная машина Mac - нарушение лицензии Apple

#### 2. Хранение данных в UserDefaults

**Почему UserDefaults**:
- Простота реализации
- Достаточно для небольшого количества будильников
- Автоматическая поддержка Codable
- Не требует дополнительных зависимостей

**Когда стоит перейти на Core Data**:
- Если будильников станет больше 100
- Если нужны сложные запросы
- Если нужна синхронизация между устройствами

#### 3. Singleton для AlarmManager

**Почему Singleton**:
- Уведомления - глобальный ресурс системы
- Не нужно несколько экземпляров
- Простой доступ из любого места кода

**Альтернатива**: Dependency Injection через EnvironmentObject
- Более "чистая" архитектура
- Но избыточно для этого случая

#### 4. Отдельные уведомления для каждого дня недели

**Почему так**:
- UNCalendarNotificationTrigger с weekday создает повторяющееся уведомление
- Но для каждого дня нужен отдельный триггер
- Это стандартный подход iOS

**Альтернатива**: Одно уведомление с кастомной логикой
- Сложнее реализовать
- Может не работать надежно в фоне

### Ограничения и их решения

#### 1. Ограничение: 64 уведомления на приложение

**Проблема**: iOS ограничивает количество запланированных уведомлений

**Решение**:
- Для большинства пользователей этого достаточно
- Если нужно больше - можно реализовать динамическое создание уведомлений
- Или использовать один будильник с кастомной логикой

**Текущая реализация**:
- Каждый день недели = одно уведомление
- Максимум: 7 дней × ~9 будильников = 63 уведомления (в пределах лимита)

#### 2. Ограничение: Переподпись каждые 7 дней

**Проблема**: Бесплатный Apple ID дает сертификат на 7 дней

**Решение**: Использование AltStore с автоматическим обновлением
- Подключение iPhone раз в неделю
- AltStore автоматически обновляет сертификаты

**Альтернативы**:
- Платный Apple Developer ($99/год) - сертификат на 1 год
- TestFlight - требует платный аккаунт, но удобнее

#### 3. Ограничение: Нет автоматической переподписи без компьютера

**Проблема**: Требуется подключение к компьютеру для переподписи

**Решение**: Принято как компромисс
- Бесплатно
- Работает надежно
- Требует минимальных усилий (раз в неделю)

**Будущие улучшения**:
- Можно настроить автоматическую переподпись через облачный сервис
- Но это требует дополнительной инфраструктуры

### Известные проблемы и их решения

#### 1. Проблема: Конфликт ID в project.pbxproj

**Симптомы**:
```
xcodebuild: error: Unable to read project 'MoscowTime.xcodeproj'.
Reason: The project 'MoscowTime' is damaged and cannot be opened.
Exception: -[XCConfigurationList group]: unrecognized selector
```

**Причина**: Один и тот же ID используется для разных типов объектов

**Решение**:
1. Найти конфликтующий ID в project.pbxproj
2. Заменить на уникальный ID
3. Убедиться, что все ссылки обновлены

**Пример**:
- Конфликт: ID `A1000004294A1A0000000005` используется для Assets.xcassets И для Build configuration list
- Решение: Изменить один из ID на `A1000004294A1A0000000006`

#### 2. Проблема: GitHub Release не создается (403 ошибка)

**Симптомы**:
```
GitHub release failed with status: 403
```

**Причина**: Недостаточно прав для создания Release

**Решение**: Добавить `permissions: contents: write` в workflow:
```yaml
build:
  permissions:
    contents: write
```

#### 3. Проблема: Симулятор не найден в lint job

**Симптомы**:
```
Unable to find a device matching the provided destination specifier:
{ platform:iOS Simulator, OS:latest, name=iPhone 15 }
```

**Причина**: Конкретный симулятор может быть недоступен

**Решение**: Использовать generic destination:
```yaml
-destination 'generic/platform=iOS Simulator'
```

#### 4. Проблема: @StateObject для AlarmManager

**Симптомы**:
```
error: generic struct 'StateObject' requires that 'AlarmManager' conform to 'ObservableObject'
```

**Причина**: AlarmManager - singleton, не должен быть ObservableObject

**Решение**: Использовать напрямую:
```swift
private let alarmManager = AlarmManager.shared
```

### Будущие улучшения

#### Возможные улучшения функциональности

1. **Повторение будильников**:
   - Добавить возможность выбора интервала (каждые N дней)
   - Добавить кастомные паттерны повторения

2. **Звуки будильников**:
   - Выбор звука для каждого будильника
   - Кастомные звуки

3. **Визуализация**:
   - График активности будильников
   - Статистика использования

4. **Синхронизация**:
   - Синхронизация между устройствами через CloudKit
   - Экспорт/импорт будильников

#### Возможные улучшения архитектуры

1. **Миграция на Core Data**:
   - Если будильников станет много
   - Для лучшей производительности

2. **Unit тесты**:
   - Тесты для AlarmStore
   - Тесты для AlarmManager
   - Тесты для форматирования времени

3. **UI тесты**:
   - Автоматизированное тестирование UI
   - Проверка создания будильников

#### Возможные улучшения процесса разработки

1. **Автоматическая переподпись**:
   - Настройка облачного сервиса для переподписи
   - Уведомления о необходимости переподписи

2. **CI/CD улучшения**:
   - Автоматическое тестирование перед сборкой
   - Автоматическое создание changelog

3. **Документация**:
   - API документация для компонентов
   - Диаграммы архитектуры

---

## Дополнительная информация

### Скрипты и инструменты

#### update-app.ps1

**Назначение**: Быстрое обновление приложения

**Использование**:
```powershell
.\update-app.ps1
.\update-app.ps1 -Message "Мое сообщение коммита"
.\update-app.ps1 -OpenActions
```

**Что делает**:
1. `git add .` - добавляет все изменения
2. `git commit -m "..."` - создает коммит
3. `git push` - отправляет в GitHub
4. Показывает ссылки на Actions и Releases
5. Опционально открывает GitHub Actions в браузере

### Файлы конфигурации

#### ExportOptions.plist

**Назначение**: Конфигурация для экспорта IPA через xcodebuild

**Содержимое**:
- `method: development` - метод экспорта
- `signingStyle: manual` - ручная подпись (но фактически не используется)

**Использование**: Попытка автоматического экспорта (обычно не срабатывает без подписи)

### Ресурсы

#### Assets.xcassets

**Структура**:
- `AppIcon.appiconset/` - иконки приложения
- Размеры: от 20x20 до 1024x1024
- Поддержка iPhone и iPad

**Генерация иконок**:
- Используется `ICON_GENERATOR.html` для создания всех размеров из одного изображения
- Инструкции в `ICON_INSTRUCTIONS.md`

### Тестирование

**Документация**: `TESTING.md`

**Содержит**:
- Подробные инструкции по установке
- Troubleshooting
- FAQ
- Информацию о переподписи

---

## Заключение

Этот документ содержит полное описание проекта MoscowTime iOS со всеми деталями и нюансами. При начале нового чата эта документация должна дать полное понимание:

- Что делает приложение
- Как оно устроено
- Как работает каждая часть
- Как происходит сборка и деплой
- Как устанавливать и использовать
- Какие есть ограничения и как они решены
- Какие известные проблемы и их решения

Для получения дополнительной информации см.:
- `README.md` - краткое описание и быстрый старт
- `TESTING.md` - инструкции по тестированию и установке
- Исходный код в папке `MoscowTime/`

